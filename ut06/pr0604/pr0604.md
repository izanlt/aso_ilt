Bloque I: Arrays fijos
1. Reconfiguración de DNS y Verificación

Como administrador, tienes un script que carga los servidores DNS de una sucursal en un array fijo. Se ha detectado que el servidor secundario está caído y la configuración actual es errónea.

Pasos a realizar:

Declara el array con los valores iniciales: 192.168.1.10 (Primario) y 10.0.0.50 (Secundario erróneo).

```powershell
$dnsServers = @("192.168.1.10", "10.0.0.50")
```

Muestra en pantalla: “Configuración actual: [Primario] - [Secundario]”.

```powershell
Write-Host "Configuración actual: $($dnsServers[0]) - $($dnsServers[1])"
```

Accede directamente al índice correspondiente y cambia la IP del secundario por la de Google: 8.8.8.8.

```powershell
$dnsServers[1] = "8.8.8.8"
```

Muestra en pantalla el número total de servidores DNS configurados.

```powershell
Write-Host "Número total de servidores DNS: $($dnsServers.Count)"
```

Muestra la configuración final corregida.

```powershell
Write-Host "Configuración final: $($dnsServers[0]) - $($dnsServers[1])
```

2. Rotación de logs de backups (LIFO - Last In, First Out)

Un sistema antiguo guarda los nombres de los últimos 3 backups en un array. Debes identificar cuál es el más antiguo y cuál el más nuevo para un informe, asumiendo que el índice 0 es el más antiguo.

Pasos a realizar:
Declara el array con las siguientes cadenas: Backup_Lunes.zip, Backup_Martes.zip, Backup_Miercoles.zip.

```powershell
$backups = @(
    "Backup_Lunes.zip",
    "Backup_Martes.zip",
    "Backup_Miercoles.zip"
)
```

Guarda en una variable $oldest el primer elemento.

```powershell
$oldest = $backups[0]
```

Guarda en una variable $newest el último elemento.

```powershell
$newest = $backups[-1]
```

El backup del Miércoles ha salido corrupto. Modifica el último elemento del array añadiéndole el texto “ (CORRUPTO)” al final del nombre.

```powershell
$backups[-1] = "$($backups[-1]) (CORRUPTO)"
```

Imprime un resumen: “Rotación de backups: Del [Viejo] al [Nuevo]”.

```powershell
Write-Host "Rotación de backups: Del $oldest al $newest"
```

Bloque II: ArrayLists
3. Gestión de Cola de incidencias (Priorización)

Estás programando un dashboard de soporte técnico. Las incidencias llegan y se ponen en cola. De repente, llega una incidencia crítica del CEO que debe saltarse la cola.

Pasos a realizar:
Crea un ArrayList vacío.

```powershell
$incidencias = [System.Collections.ArrayList]::new()
```

Añade las incidencias: “Monitor parpadea” y “Ratón no va”. (Recuerda ocultar la salida por pantalla del .Add()).

```powershell
$null = $incidencias.Add("Monitor parpadea")
```

```powershell
$null = $incidencias.Add("Ratón no va")
```

Llega una urgencia: Inserta en la posición 0 la incidencia: “SERVIDOR CAÍDO”.

```powershell
$incidencias.Insert(0, "SERVIDOR CAÍDO")
```

El técnico resuelve la incidencia del “Ratón”. Búscala por su nombre y elimínala de la lista.

```powershell
$incidencias.Remove("Ratón no va")
```


Imprime la lista actual de tareas pendientes y cuenta cuántas quedan.

```powershell
Write-Host "Total pendientes: $($incidencias.Count)"
```

4. Validación de lista negra de IPs (Seguridad)

Tu script de firewall recibe IPs sospechosas y debe decidir si bloquearlas o no.

Pasos a realizar:

Inicializa un ArrayList con las IPs ya bloqueadas: 10.10.10.5, 192.168.50.4, 80.80.80.80.

```powershell
$blacklist = [System.Collections.ArrayList]::new()
$blacklist.Add("10.10.10.5") | Out-Null
$blacklist.Add("192.168.50.4") | Out-Null
$blacklist.Add("80.80.80.80") | Out-Null
```

Declara una variable $nuevaAmenaza = "192.168.50.4".

```powershell
$nuevaAmenaza = "192.168.50.4"
```

Usa una estructura if para:
Si la IP ya está en la lista, muestra: “La IP [IP] ya estaba bloqueada. No se hace nada.”

```powershell
if ($blacklist -contains $nuevaAmenaza) {
    Write-Host "La IP $nuevaAmenaza ya estaba bloqueada. No se hace nada."
```

Si no está, añádela a la lista y muestra: “IP [IP] añadida a la lista negra.”

```powershell
if ($blacklist -contains $nuevaAmenaza) {
    Write-Host "La IP $nuevaAmenaza ya estaba bloqueada. No se hace nada."
} else {
    $blacklist.Add($nuevaAmenaza) | Out-Null
    Write-Host "IP $nuevaAmenaza añadida a la lista negra."
}
```

Muestra la lista final ordenada alfabéticamente

```powershell
$blacklist | Sort-Object
```

Bloque III: Listas genéricas
5. Hardening de puertos de Firewall (List[int])

Vamos a configurar una regla de firewall que solo permite ciertos puertos numéricos.

Pasos a realizar:

Instancia una nueva lista genérica que solo acepte Enteros: [System.Collections.Generic.List[int]]::new().

```powershell
$puertosPermitidos = [System.Collections.Generic.List[int]]::new()
```

Añade los puertos estándar: 80, 443, 53.

```powershell
$puertosPermitidos.Add(80)
$puertosPermitidos.Add(443)
$puertosPermitidos.Add(53)
```

Por error, alguien abrió el puerto Telnet (23). Añádelo a la lista.

```powershell
$puertosPermitidos.Add(23)
```

Auditoría de seguridad: Elimina el puerto 23 de la lista.

```powershell
$puertosPermitidos.Remove(23)
```

Intenta añadir (solo escribe la línea comentada) el texto “HTTP” a la lista y explica en un comentario qué error daría.

Muestra la lista de puertos permitidos ordenada de menor a mayor.

```powershell
Write-Host "Puertos permitidos:"
$puertosPermitidos | Sort-Object
```

6. Inventario de servicios críticos (List[string])

Necesitas monitorizar una lista de servicios de Windows.

Pasos a realizar:
Crea una lista genérica de Strings a partir de un array existente (::new($array)): Array origen: Spooler, W3SVC, LanmanWorkstation.

```powershell
$serviciosArray = @("Spooler", "W3SVC", "LanmanWorkstation")
```

Te das cuenta de que falta el servicio de actualizaciones. Añade “wuauserv”.

```powershell
$serviciosArray.Add("wuauserv")
```

Ordena la lista alfabéticamente.

```powershell
$servicios = $servicios | Sort-Object
```

Recorre la lista (foreach) y para cada elemento muestra el mensaje: “Monitorizando servicio: [NombreServicio]… OK”.

```powershell
foreach ($servicio in $servicios) {
    Write-Host "Monitorizando servicio: $servicio... OK"
}
```

Bloque IV: Manipulación de texto
7. Análisis de Log de usuario

Tienes una línea de log cruda extraída de un servidor Linux. Necesitas sacar el usuario y la IP limpia.

Entrada: $logLine = " User: admin ; IP: 192.168.1.55 ; Status: Failed " (Nota los espacios extra al principio y final).
Pasos a realizar:
Limpia los espacios en blanco sobrantes del principio y el final de la cadena original.

```powershell
$cleanLog = $logLine.Trim()
```

Divide la cadena usando el punto y coma ; como separador.

```powershell
$parts = $cleanLog -split ";"
```

El primer elemento será “User: admin”. Vuelve a dividirlo para quedarte solo con “admin”.

```powershell
$userPart = $parts[0].Trim() -split ":"
```

El segundo elemento es la IP. Límpialo para obtener solo “192.168.1.55”.

```powershell
$ipPart = $parts[1].Trim() -split ":"
```

Muestra un mensaje final claro: “ALERTA: El usuario [Usuario] intentó conectar desde [IP]”.

```powershell
Write-Host "ALERTA: El usuario $usuario intentó conectar desde $ip"
```

8. Generador de CSV para recursos humanos

RRHH te pide un listado de los correos de los nuevos empleados separados por comas para importarlos en su herramienta de Mailing.

Pasos a realizar:
Tienes tres variables con correos: $m1="ana@empresa.com", $m2="luis@empresa.com", $m3="bea@empresa.com".

```powershell
$m1 = "ana@empresa.com"
$m2 = "luis@empresa.com"
$m3 = "bea@empresa.com"
```

Crea un array temporal que contenga esas tres variables.

```powershell
$emails = @($m1, $m2, $m3)
```

Utiliza el operador -join para crear una única cadena de texto separada por comas ,.

```powershell
$csvLine = "EmailAddress," + ($emails -join ",")
```

Muestra el resultado, que debería parecerse al contenido de un archivo .csv.

```powershell
Write-Host $csvLine
```
